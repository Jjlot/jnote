#+TITLE: Python
#+STARTUP: showall


* Basic knowledge
** 字典代替复杂的if-else分支
#+begin_src python :results output
def f(x):
    if x == 'a':
        return 1
    elif x == 'b':
        return 2
    else:
        return 9
#+end_src

#+begin_src python :results output
def f(x):
    return {
        'a': 1,
        'b': 2
    }.get(x, 9)
#+end_src

** import
*** import from self
#+begin_src python :results output
class What(object):
    @staticmethod
    def what_is_what():
        print('what is what')


What.what_is_what()


from . import What as where
where.what_is_what()
#+end_src

** Format output
#+begin_src python :results output
print("a = %s, b = %s" % (a, b))
#+end_src

** Exception
#+begin_src python :results output
class Networkerror(Exception):
    def __init__(self, arg):
        self.input_string = arg
        # print(self.args)

try:
    raise Networkerror("Bad request")

except Networkerror as exc:
    print(exc.input_string)
    raise RuntimeError("run-time-error") from exc

except KeyboardInterrupt:
    print("Interrupt by keyboard")

except:
    print("All the exceptions")

finally:
    print("finally")
#+end_src

** Build-in exceptions
https://docs.python.org/3/library/exceptions.html#bltin-exceptions

** Build-in functions
*** dir()
The dir() method tries to return a list of valid attributes of the object.

dir(list) or dir(<Class name>) or dir(<Object name>)

** str
*** join
'-'.join(('prefix', 'infix', 'postfix'))

** utf-8 comments
# -*- coding: utf-8 -*-

** path
//usr/local/lib64/python3.6/site-packages/

/usr/lib/python2.7/site-packages

* Code sections
** Generate a new table from a known table
#+begin_src python :results output
# create the teams table and the players.team_id column
Team.__table__.create(bind)
op.add_column('players', sa.Column('team_id', sa.ForeignKey('teams.id'), nullable=False)

# create teams for each team name
teams = {name: Team(name=name) for name in session.query(Player.team).distinct()}
session.add_all(teams.values())

# set player team based on team name
for player in session.query(Player):
player.team = teams[player.team_name]

session.commit()
#+end_src

** 强制子类重写父类中的方法
#+begin_src python :results output
import abc
import six

@six.add_metaclass(abc.ABCMeta)
class Animal(object):
    @abc.abstractmethod
    def speak(self):
        pass
#+end_src

** 单例模式
*** Method 2
#+begin_src python :results output
_CALLBACK_MANAGER = None

def _get_callback_manager():
    global _CALLBACK_MANAGER
    if _CALLBACK_MANAGER is None:
        _CALLBACK_MANAGER = manager.CallbacksManager()
    return _CALLBACK_MANAGER

_get_callback_manager().subscribe(callback, resource, event, priority)
#+end_src

** Time duration
*** The simple way
#+BEGIN_SRC python
import datetime

start = datetime.datetime.now()
# Some process
end = datetime.datetime.now()

duration = end - start
print(' ----->time result: start at %s, end at %s, duration %s\n', str(start), str(end), str(duration))
#+END_SRC

*** Decorator based
#+begin_src python :results output
from time import time

def timeit(f):

    def timed(*args, **kw):

        ts = time()
        result = f(*args, **kw)
        te = time()

        print('func:%r args:[%r, %r] took: %2.4f sec' % (f.__name__, args, kw, te-ts))
        return result

    return timed

@timeit
def foo():
    print('hi')
#+end_src

*** Class-based Context Manager
#+begin_src python :results output
from time import time

class Timer(object):
    def __init__(self, description):
        self.description = description

    def __enter__(self):
        self.start = time()

    def __exit__(self, type, value, traceback):
        self.end = time()
        print('%s: %s' % (self.description, self.end - self.start))


with Timer("List Comprehension Example"):
    s = [x for x in range(10000000)]
#+end_src

* Packages
** flake8
将 PEP 8、Pyflakes（类似 Pylint）、McCabe（代码复杂性检查器）和第三方插件整合到一起，以检查 Python 代码风格和质量的一个 Python 工具

files that contain this line are skipped: #flake8: noqa

lines that contain a # noqa comment at the end will not issue warnings.

针对目前pep8尚未支持命名规范的检查，有人开发出了此款插件作为规则补充。

pep8-naming插件安装完成之后，会新增一类错误返回码以N开头：N***: pep8-naming返回的错误类型。

*** install
pip install pep8-naming

*** commond sample
flake8 --max-line-length=130 --exclude migration,tests --max-complexity 12

*** pep8
Style Guide for Python Code

*** awesome-flake8-extensions
https://github.com/DmytroLitvinov/awesome-flake8-extensions

** tox
tox aims to automate and standardize testing in Python.

是用来管理和构建虚拟环境(virtualenv)的。对于一个项目，我们需要运行Python 2.7的单元测试，也需要运行Python 3.4的单元测试，还需要运行PEP8的代码检查。这些不同的任务需要依赖不同的库，所以需要使用不同的虚拟环境。使用tox的时候，我们会在tox的配置文件 tox.ini 中指定不同任务的虚拟环境名称，该任务在虚拟环境中需要安装哪些包，以及该任务执行的时候需要运行哪些命令。

pip3 install tox

tox -v -e py36

** unittest
*** basic sample
#+begin_src python :results output
# -*- coding: utf-8 -*-

import unittest

class TestStringMethods(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        """Class执行前运行这个"""
        print("-->setUpClass")

    @classmethod
    def tearDownClass(cls):
        """Class执行结束后运行这个"""
        print("-->tearDownClass")

    def setUp(self):
        """每个test case执行前运行这个"""
        print("\n---->setUp")

    def tearDown(self):
        """test case执行完运行这个"""
        print("---->tearDown")

    def test_upper(self):
        """打印结果的时候可以看到这一行"""
        self.assertEqual('foo'.upper(), 'FOO')

    def test_isupper(self):
        self.assertTrue('FOO'.isupper())
        self.assertFalse('Foo'.isupper())

    def test_split(self):
        s = 'hello world'
        self.assertEqual(s.split(), ['hello', 'world'])
        # check that s.split fails when the separator is not a string
        with self.assertRaises(TypeError):
            s.split(2)

    @unittest.skip("I don't want to run this case.")
    def test_skip(self):
        print("you'll never see this")


if __name__ == '__main__':
    unittest.main()
#+end_src

*** run
python3 test.py

python3 test.py -v

** mock
*** patch
#+begin_src python :results output
from unittest.mock import patch


class ProductionClass(object):
    def __init__(self):
        pass

    @staticmethod
    def method(a, b, c):
        print('method is called', a, b, c)


def say_something():
    print('ok i will say something')


with patch.object(ProductionClass, 'method', return_value=None, side_effect=say_something()) as mock_method:
    thing = ProductionClass()
    thing.method(1, 2, 3)


thing = ProductionClass()
thing.method(1, 2, 3)
#+end_src

** prettytable
#+begin_src python :results output
from prettytable import PrettyTable

x = PrettyTable()

x.field_names = ["City name", "Area", "Population", "Annual Rainfall"]
x.add_row(["Adelaide", 1295, 1158259, 600.5])
x.add_row(["Brisbane", 5905, 1857594, 1146.4])

print(x)
#+end_src

** argparse
#+begin_src python :results output
import argparse

parser = argparse.ArgumentParser(description='This is the description')

parser.add_argument('-s',
                    '--string',
                    dest='sample_string',
                    type=str,
                    default='default',
                    required=False,
                    help='Write help here')


args = parser.parse_args()

if args.sample_string:
    print(args.sample_string)
else:
    print('no input')

parser.print_help()
#+end_src

** syslog
#+begin_src python :results output
import syslog

syslog.syslog('String test')
#+end_src

** logging
#+begin_src python :results output
import logging

logging.basicConfig(filename='logger.log', encoding='utf-8')

# getLogger前要先basicConfig
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(message)s', datefmt='%d-%b-%y %H:%M:%S')

logging.debug('This is a debug message')

logging.info('This is an info message')

logging.warning('This is a warning message')

logging.error('This is an error message')

logging.critical('This is a critical message')

logger = logging.getLogger('example_logger')

logger.warning('%s before you %s', 'Look', 'leap!')

LOG = logging.getLogger(__name__)

LOG.info('In log')
#+end_src

*** Exception
#+begin_src python :results output
import logging

try:
    raise Exception()
except Exception as e:
    logging.error("EEEE", exc_info=True)
#+end_src
#+begin_src python :results output
import logging

try:
    raise Exception()
except Exception:
    logging.exception("EEEE")
#+end_src

*** 捕获traceback
#+begin_src python :results output
try:
    1/0
except Exception:
    logging.error("Something error", exc_info=True)
#+end_src

*** 自定义logging格式
参考 from logging import LoggerAdapter

*** python 日志 logging模块(详细解析)
https://blog.csdn.net/pansaky/article/details/90710751

*** Python之日志处理（logging模块）
https://www.cnblogs.com/yyds/p/6901864.html

*** Python之向日志输出中添加上下文信息
https://www.cnblogs.com/yyds/p/6897964.html

** random
#+begin_src python :results output
import random
n = random.randint(0,22)
print(n)
#+end_src

** sqlalchemy
#+begin_src python :results output
  # A study logging for Object Relational Tutorial
  # refs from: https://docs.sqlalchemy.org/en/14/orm/tutorial.html
  #

  from sqlalchemy.ext.declarative import declarative_base
  from sqlalchemy import create_engine
  from sqlalchemy import Column, Integer, String
  from sqlalchemy import func
  from sqlalchemy import text
  from sqlalchemy import ForeignKey
  from sqlalchemy.orm import sessionmaker
  from sqlalchemy.orm import relationship


  Base = declarative_base()
  # The in-memory-only SQLite database from sqlalchemy tutorial
  # more common sample is 'mysql+pymysql://root@127.0.0.1/sparrow_player'
  engine = create_engine('sqlite:///:memory:', echo=True, pool_recycle=3600)

  Session = sessionmaker(bind=engine)
  session = Session()


  class User(Base):
      __tablename__ = 'users'

      id = Column(Integer, primary_key=True)
      name = Column(String)
      fullname = Column(String)
      nickname = Column(String)

      # 不是很理解这东西对谁友好了
      def __repr__(self):
          return "<User(name='%s', fullname='%s', nickname='%s')>" % (self.name, self.fullname, self.nickname)

  class Address(Base):
      __tablename__ = 'addresses'
      id = Column(Integer, primary_key=True)
      email_address = Column(String, nullable=False)
      # Indicate the foreigner key
      user_id = Column(Integer, ForeignKey('users.id'))

      # TODO: Address表中的user是User表，back_populates是干啥的？
      user = relationship("User", back_populates="addresses")

  # User表中的address是Address表
  User.addresses = relationship(
      "Address", order_by=Address.id, back_populates="user")

  # TODO: 这句可能是create table的
  Base.metadata.create_all(engine)

  # Add one objects
  ed_user = User(name='ed', fullname='Ed Jones', nickname='edsnickname')
  session.add(ed_user)
  session.commit()

  # Add multi objects
  session.add_all([
      User(name='wendy', fullname='Wendy Williams', nickname='windy'),
      User(name='mary', fullname='Mary Contrary', nickname='mary'),
      User(name='fred', fullname='Fred Flintstone', nickname='freddy')])
  session.commit()

  # Query
  our_user = session.query(User).\
      filter_by(name='ed').first()
  print(our_user)

  # Query, order_by
  for instance in session.query(User).order_by(User.id):
      print(instance.name, instance.fullname)

  # Query, indicate column
  for name, fullname in session.query(User.name, User.fullname):
      print(name, fullname)

  # Query, filter
  for user in session.query(User).\
          filter(User.name=='ed').\
          filter(User.fullname=='Ed Jones'):
      print(user)

  # Query, count
  users_count = session.query(User).count()

  # 单纯的query并不会出发sql查询，until the count() is called
  # 所以query是some type，count是some type，可能是类似返回result的函数
  q = session.query(User)
  print(q.count())

  # Efficient count
  print(session.query(func.count(User.id)).scalar())

  # Query, origin SQL
  session.query(User).from_statement(
      text("SELECT * FROM users where name=:name")).params(name='ed').all()

  # Add related objects
  jack = User(name='jack', fullname='Jack Bean', nickname='gjffdd')
  jack.addresses = [
      Address(email_address='jack@google.com'),
      Address(email_address='j25@yahoo.com')]
  session.add(jack)
  session.commit()

  # Query related objects
  jack = session.query(User).filter_by(name='jack').one()
  print(jack)
  for address in jack.addresses:
      print(address.email_address)

  # Delete object, jack is querried up there
  session.delete(jack)
  session.query(User).filter_by(name='jack').count()

  # is active
  session.is_active
#+end_src
*** transaction
with session.begin(subtransactions=True):

*** Configuring Logging
**** logging to sys.stdout when create_engine()
create_engine.echo

create_engine.echo_pool

**** python logging
#+begin_src python :results output
logging.basicConfig()
logging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)
#+end_src

*** one to one (without reverse)
#+begin_src python :results output
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import create_engine
from sqlalchemy import Column, Integer, String
from sqlalchemy import ForeignKey
from sqlalchemy.orm import sessionmaker
from sqlalchemy.orm import relationship

Base = declarative_base()
engine = create_engine('sqlite:///:memory:', echo=False, pool_recycle=3600)

Session = sessionmaker(bind=engine)
session = Session()


class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    name = Column(String)
    address = relationship("Address", uselist=False)

class Address(Base):
    __tablename__ = 'addresses'
    id = Column(Integer, primary_key=True)
    email_address = Column(String, nullable=False)

    user_id = Column(Integer, ForeignKey('users.id'))

Base.metadata.create_all(engine)

# Add related objects
jack = User(name='jack')
jack.address = Address(email_address='jack@google.com')
session.add(jack)
session.commit()

jack = session.query(User).filter_by(name='jack').one()
print('user: %s, email: %s' % (jack.name, jack.address.email_address))
#+end_src
*** one to one (with reverse)
#+begin_src python :results output
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import create_engine
from sqlalchemy import Column, Integer, String
from sqlalchemy import ForeignKey
from sqlalchemy.orm import sessionmaker
from sqlalchemy.orm import relationship

Base = declarative_base()
engine = create_engine('sqlite:///:memory:', echo=False, pool_recycle=3600)

Session = sessionmaker(bind=engine)
session = Session()


class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    name = Column(String)
    address = relationship("Address", uselist=False, back_populates="user")

class Address(Base):
    __tablename__ = 'addresses'
    id = Column(Integer, primary_key=True)
    email_address = Column(String, nullable=False)

    user_id = Column(Integer, ForeignKey('users.id'))
    user = relationship("User", back_populates="address")

Base.metadata.create_all(engine)

# Add related objects
jack = User(name='jack')
jack.address = Address(email_address='jack@google.com')
session.add(jack)
session.commit()

jack = session.query(User).filter_by(name='jack').one()
print('user: %s, email: %s' % (jack.name, jack.address.email_address))

jack = session.query(Address).filter_by(email_address='jack@google.com').one()
print(jack.user.name)
#+end_src
*** one to many
#+begin_src python :results output
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import create_engine
from sqlalchemy import Column, Integer, String
from sqlalchemy import ForeignKey
from sqlalchemy.orm import sessionmaker
from sqlalchemy.orm import relationship

Base = declarative_base()
engine = create_engine('sqlite:///:memory:', echo=False, pool_recycle=3600)

Session = sessionmaker(bind=engine)
session = Session()


class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    name = Column(String)
    address = relationship("Address", uselist=True, back_populates="user")

class Address(Base):
    __tablename__ = 'addresses'
    id = Column(Integer, primary_key=True)
    email_address = Column(String, nullable=False)

    user_id = Column(Integer, ForeignKey('users.id'))
    user = relationship("User", back_populates="address")

Base.metadata.create_all(engine)

# Add related objects
jack = User(name='jack')
jack.address = [
    Address(email_address='jack@google.com'),
    Address(email_address='jack@yahoo.com')
    ]
session.add(jack)
session.commit()

jack = session.query(User).filter_by(name='jack').one()
for address in jack.address:
    print('user: %s, email: %s' % (jack.name, address.email_address))

jack = session.query(Address).filter_by(email_address='jack@google.com').one()
print(jack.user.name)
#+end_src

*** distinct
指定字段去重的结果

db.session.query(User).distinct(User.name).all()

*** in_, notin_
session.query(User).filter(User.name.in_(user_name_list)).all()

** setuptools
python3 setup.py bdist_rpm
*** pbr

*** files
**** packages
指定需要包含的包，行为类似于setuptools.find_packages

**** data_files
指定目的目录和源文件路径

* Openstack
** call back
#+begin_src python :results output
from neutron_lib.callbacks import events
from neutron_lib.callbacks import resources
from neutron_lib.callbacks import registry

"""
This method(notify) is deprecated in favor of publish() and will be removed in Queens.
"""

class PublishEventPayload(events.EventPayload):
    def __init__(self, context, metadata=None, request_body=None,
                 states=None, resource_id=None, name=None):

        super(PublishEventPayload, self).__init__(
            context, metadata=metadata, request_body=request_body,
            states=states, resource_id=resource_id)

        self.name = name


def module_callback(resource, event, trigger, payload):
    print('module callback got a payload of metadata = %s, name = %s' % (payload.metadata, payload.name))


class MyCallback(object):
    @staticmethod
    def object_callback(resource, event, trigger, payload):
        print('object callback')

    @classmethod
    def class_callback(cls, resource, event, trigger, payload):
        print('class callback')


c = MyCallback()
registry.subscribe(module_callback, resources.ROUTER, events.BEFORE_CREATE)
registry.subscribe(c.object_callback, resources.ROUTER, events.BEFORE_CREATE)
registry.subscribe(MyCallback.class_callback, resources.ROUTER, events.BEFORE_CREATE)


def notify_callback(resource, event, trigger, **kwargs):
    print('notify by %s, id is %s, name is %s' % (trigger.__name__, kwargs['id'], kwargs['name']))

registry.subscribe(notify_callback, resources.ROUTER, events.AFTER_CREATE)


def do_notify():
    def nested_subscribe(resource, event, trigger, payload):
        print('nested callback')

    registry.subscribe(nested_subscribe, resources.ROUTER, events.BEFORE_CREATE)

    # publish, why the order is indeterminate?
    registry.publish(resources.ROUTER, events.BEFORE_CREATE, do_notify, PublishEventPayload(None, metadata='btw', name='moka'))

    # notify
    registry.notify(resources.ROUTER, events.AFTER_CREATE, do_notify, id='10', name='your_name')


print('Notifying...')
do_notify()

#+end_src

* Todo
** click

** lambda

** @abc.abstractmethod
修饰的抽象类的函数入参怎么写

子类入参要完全一致吗

可以控制子类必须包含哪些入参吗

** testr

** what is this?
test tcp-connection 135.242.143.93 22[10]

** coverage erase
coverage erase
           py.test --cov={toxinidir}/src -sx tests
           coverage html

** fabric

** virtualenv
*** setup
pip install virtualenv

*** create env
virtualenv test-env

virtualenv -p /usr/bin/python2.7 env27

*** use & unuse
source env2.7/bin/activate

deactivate

*** TODO virtualenvwrapper
virtualenvwrapper

** requirements
pip freeze > requirements.txt

pip install -r requirements.txt

