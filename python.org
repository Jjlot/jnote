#+TITLE: Python
#+STARTUP: showall


* Basic knowledge
** Format output
#+begin_src python :results output
print("a = %s, b = %s" % (a, b))
#+end_src

** Exception
#+begin_src python :results output
class Networkerror(Exception):
    def __init__(self, arg):
        self.input_string = arg
        # print(self.args)

try:
    raise Networkerror("Bad request")

except Networkerror as exc:
    print(exc.input_string)
    raise RuntimeError("run-time-error") from exc

except KeyboardInterrupt:
    print("Interrupt by keyboard")

except:
    print("All the exceptions")

finally:
    print("finally")
#+end_src

** Build-in exceptions
https://docs.python.org/3/library/exceptions.html#bltin-exceptions

** Build-in functions
*** dir()
The dir() method tries to return a list of valid attributes of the object.

dir(list) or dir(<Class name>) or dir(<Object name>)

** str
*** join
'-'.join(('prefix', 'infix', 'postfix'))

* Code sections
** 强制子类重写父类中的方法
#+begin_src python :results output
import abc
import six

@six.add_metaclass(abc.ABCMeta)
class Animal(object):
    @abc.abstractmethod
    def speak(self):
        pass
#+end_src

** 单例模式
*** Method 2
#+begin_src python :results output
_CALLBACK_MANAGER = None

def _get_callback_manager():
    global _CALLBACK_MANAGER
    if _CALLBACK_MANAGER is None:
        _CALLBACK_MANAGER = manager.CallbacksManager()
    return _CALLBACK_MANAGER

_get_callback_manager().subscribe(callback, resource, event, priority)
#+end_src

** Time duration
*** The simple way
#+BEGIN_SRC python
import datetime

start = datetime.datetime.now()
# Some process
end = datetime.datetime.now()

duration = end - start
print(' ----->time result: start at %s, end at %s, duration %s\n', str(start), str(end), str(duration))
#+END_SRC

*** Decorator based
#+begin_src python :results output
from time import time

def timeit(f):

    def timed(*args, **kw):

        ts = time()
        result = f(*args, **kw)
        te = time()

        print('func:%r args:[%r, %r] took: %2.4f sec' % (f.__name__, args, kw, te-ts))
        return result

    return timed

@timeit
def foo():
    print('hi')
#+end_src

*** Class-based Context Manager
#+begin_src python :results output
from time import time

class Timer(object):
    def __init__(self, description):
        self.description = description

    def __enter__(self):
        self.start = time()

    def __exit__(self, type, value, traceback):
        self.end = time()
        print('%s: %s' % (self.description, self.end - self.start))


with Timer("List Comprehension Example"):
    s = [x for x in range(10000000)]
#+end_src

* Packages
** prettytable
#+begin_src python :results output
from prettytable import PrettyTable

x = PrettyTable()

x.field_names = ["City name", "Area", "Population", "Annual Rainfall"]
x.add_row(["Adelaide", 1295, 1158259, 600.5])
x.add_row(["Brisbane", 5905, 1857594, 1146.4])

print(x)
#+end_src

** argparse
#+begin_src python :results output
import argparse

parser = argparse.ArgumentParser(description='This is the description')

parser.add_argument('-s',
                    '--string',
                    dest='sample_string',
                    type=str,
                    default='default',
                    required=False,
                    help='Write help here')


args = parser.parse_args()

if args.sample_string:
    print(args.sample_string)
else:
    print('no input')

parser.print_help()
#+end_src

** syslog
#+begin_src python :results output
import syslog

syslog.syslog('String test')
#+end_src

** logging
#+begin_src python :results output
import logging

logging.basicConfig(filename='logger.log', encoding='utf-8')

# getLogger前要先basicConfig
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(message)s', datefmt='%d-%b-%y %H:%M:%S')

logging.debug('This is a debug message')

logging.info('This is an info message')

logging.warning('This is a warning message')

logging.error('This is an error message')

logging.critical('This is a critical message')

logger = logging.getLogger('example_logger')

logger.warning('%s before you %s', 'Look', 'leap!')

LOG = logging.getLogger(__name__)

LOG.info('In log')
#+end_src

*** Exception
#+begin_src python :results output
import logging

try:
    raise Exception()
except Exception as e:
    logging.error("EEEE", exc_info=True)
#+end_src
#+begin_src python :results output
import logging

try:
    raise Exception()
except Exception:
    logging.exception("EEEE")
#+end_src

*** 捕获traceback
#+begin_src python :results output
try:
    1/0
except Exception:
    logging.error("Something error", exc_info=True)
#+end_src

*** 自定义logging格式
参考 from logging import LoggerAdapter

*** python 日志 logging模块(详细解析)
https://blog.csdn.net/pansaky/article/details/90710751

*** Python之日志处理（logging模块）
https://www.cnblogs.com/yyds/p/6901864.html

*** Python之向日志输出中添加上下文信息
https://www.cnblogs.com/yyds/p/6897964.html

** random
#+begin_src python :results output
import random
n = random.randint(0,22)
print(n)
#+end_src

* Openstack
** call back
#+begin_src python :results output
from neutron_lib.callbacks import events
from neutron_lib.callbacks import resources
from neutron_lib.callbacks import registry

"""
This method(notify) is deprecated in favor of publish() and will be removed in Queens.
"""

class PublishEventPayload(events.EventPayload):
    def __init__(self, context, metadata=None, request_body=None,
                 states=None, resource_id=None, name=None):

        super(PublishEventPayload, self).__init__(
            context, metadata=metadata, request_body=request_body,
            states=states, resource_id=resource_id)

        self.name = name


def module_callback(resource, event, trigger, payload):
    print('module callback got a payload of metadata = %s, name = %s' % (payload.metadata, payload.name))


class MyCallback(object):
    @staticmethod
    def object_callback(resource, event, trigger, payload):
        print('object callback')

    @classmethod
    def class_callback(cls, resource, event, trigger, payload):
        print('class callback')


c = MyCallback()
registry.subscribe(module_callback, resources.ROUTER, events.BEFORE_CREATE)
registry.subscribe(c.object_callback, resources.ROUTER, events.BEFORE_CREATE)
registry.subscribe(MyCallback.class_callback, resources.ROUTER, events.BEFORE_CREATE)


def notify_callback(resource, event, trigger, **kwargs):
    print('notify by %s, id is %s, name is %s' % (trigger.__name__, kwargs['id'], kwargs['name']))

registry.subscribe(notify_callback, resources.ROUTER, events.AFTER_CREATE)


def do_notify():
    def nested_subscribe(resource, event, trigger, payload):
        print('nested callback')

    registry.subscribe(nested_subscribe, resources.ROUTER, events.BEFORE_CREATE)

    # publish, why the order is indeterminate?
    registry.publish(resources.ROUTER, events.BEFORE_CREATE, do_notify, PublishEventPayload(None, metadata='btw', name='moka'))

    # notify
    registry.notify(resources.ROUTER, events.AFTER_CREATE, do_notify, id='10', name='your_name')


print('Notifying...')
do_notify()

#+end_src

* Todo
** click

** lambda
