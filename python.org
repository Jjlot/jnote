#+TITLE: Python
#+STARTUP: showall


* Basic knowledge
** Format output
#+begin_src python :results output
print("a = %s, b = %s" % (a, b))
#+end_src

** Exception
#+begin_src python :results output
class Networkerror(Exception):
    def __init__(self, arg):
        self.input_string = arg
        # print(self.args)

try:
    raise Networkerror("Bad request")

except Networkerror as exc:
    print(exc.input_string)
    raise RuntimeError("run-time-error") from exc

except KeyboardInterrupt:
    print("Interrupt by keyboard")

except:
    print("All the exceptions")

finally:
    print("finally")
#+end_src

** Build-in exceptions
https://docs.python.org/3/library/exceptions.html#bltin-exceptions

** Build-in functions
*** dir()
The dir() method tries to return a list of valid attributes of the object.

dir(list) or dir(<Class name>) or dir(<Object name>)

** str
*** join
'-'.join(('prefix', 'infix', 'postfix'))

** utf-8 comments
# -*- coding: utf-8 -*-

** path
//usr/local/lib64/python3.6/site-packages/

/usr/lib/python2.7/site-packages

* Code sections
** 强制子类重写父类中的方法
#+begin_src python :results output
import abc
import six

@six.add_metaclass(abc.ABCMeta)
class Animal(object):
    @abc.abstractmethod
    def speak(self):
        pass
#+end_src

** 单例模式
*** Method 2
#+begin_src python :results output
_CALLBACK_MANAGER = None

def _get_callback_manager():
    global _CALLBACK_MANAGER
    if _CALLBACK_MANAGER is None:
        _CALLBACK_MANAGER = manager.CallbacksManager()
    return _CALLBACK_MANAGER

_get_callback_manager().subscribe(callback, resource, event, priority)
#+end_src

** Time duration
*** The simple way
#+BEGIN_SRC python
import datetime

start = datetime.datetime.now()
# Some process
end = datetime.datetime.now()

duration = end - start
print(' ----->time result: start at %s, end at %s, duration %s\n', str(start), str(end), str(duration))
#+END_SRC

*** Decorator based
#+begin_src python :results output
from time import time

def timeit(f):

    def timed(*args, **kw):

        ts = time()
        result = f(*args, **kw)
        te = time()

        print('func:%r args:[%r, %r] took: %2.4f sec' % (f.__name__, args, kw, te-ts))
        return result

    return timed

@timeit
def foo():
    print('hi')
#+end_src

*** Class-based Context Manager
#+begin_src python :results output
from time import time

class Timer(object):
    def __init__(self, description):
        self.description = description

    def __enter__(self):
        self.start = time()

    def __exit__(self, type, value, traceback):
        self.end = time()
        print('%s: %s' % (self.description, self.end - self.start))


with Timer("List Comprehension Example"):
    s = [x for x in range(10000000)]
#+end_src

* Packages
** prettytable
#+begin_src python :results output
from prettytable import PrettyTable

x = PrettyTable()

x.field_names = ["City name", "Area", "Population", "Annual Rainfall"]
x.add_row(["Adelaide", 1295, 1158259, 600.5])
x.add_row(["Brisbane", 5905, 1857594, 1146.4])

print(x)
#+end_src

** argparse
#+begin_src python :results output
import argparse

parser = argparse.ArgumentParser(description='This is the description')

parser.add_argument('-s',
                    '--string',
                    dest='sample_string',
                    type=str,
                    default='default',
                    required=False,
                    help='Write help here')


args = parser.parse_args()

if args.sample_string:
    print(args.sample_string)
else:
    print('no input')

parser.print_help()
#+end_src

** syslog
#+begin_src python :results output
import syslog

syslog.syslog('String test')
#+end_src

** logging
#+begin_src python :results output
import logging

logging.basicConfig(filename='logger.log', encoding='utf-8')

# getLogger前要先basicConfig
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(message)s', datefmt='%d-%b-%y %H:%M:%S')

logging.debug('This is a debug message')

logging.info('This is an info message')

logging.warning('This is a warning message')

logging.error('This is an error message')

logging.critical('This is a critical message')

logger = logging.getLogger('example_logger')

logger.warning('%s before you %s', 'Look', 'leap!')

LOG = logging.getLogger(__name__)

LOG.info('In log')
#+end_src

*** Exception
#+begin_src python :results output
import logging

try:
    raise Exception()
except Exception as e:
    logging.error("EEEE", exc_info=True)
#+end_src
#+begin_src python :results output
import logging

try:
    raise Exception()
except Exception:
    logging.exception("EEEE")
#+end_src

*** 捕获traceback
#+begin_src python :results output
try:
    1/0
except Exception:
    logging.error("Something error", exc_info=True)
#+end_src

*** 自定义logging格式
参考 from logging import LoggerAdapter

*** python 日志 logging模块(详细解析)
https://blog.csdn.net/pansaky/article/details/90710751

*** Python之日志处理（logging模块）
https://www.cnblogs.com/yyds/p/6901864.html

*** Python之向日志输出中添加上下文信息
https://www.cnblogs.com/yyds/p/6897964.html

** random
#+begin_src python :results output
import random
n = random.randint(0,22)
print(n)
#+end_src

** sqlalchemy
#+begin_src python :results output
# A study logging for Object Relational Tutorial
# refs from: https://docs.sqlalchemy.org/en/14/orm/tutorial.html
#

from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import create_engine
from sqlalchemy import Column, Integer, String
from sqlalchemy import func
from sqlalchemy import text
from sqlalchemy import ForeignKey
from sqlalchemy.orm import sessionmaker
from sqlalchemy.orm import relationship


Base = declarative_base()
# The in-memory-only SQLite database from sqlalchemy tutorial
# more common sample is 'mysql+pymysql://root@127.0.0.1/sparrow_player'
engine = create_engine('sqlite:///:memory:', echo=True, pool_recycle=3600)

Session = sessionmaker(bind=engine)
session = Session()


class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    name = Column(String)
    fullname = Column(String)
    nickname = Column(String)

    # 不是很理解这东西对谁友好了
    def __repr__(self):
        return "<User(name='%s', fullname='%s', nickname='%s')>" % (self.name, self.fullname, self.nickname)

class Address(Base):
    __tablename__ = 'addresses'
    id = Column(Integer, primary_key=True)
    email_address = Column(String, nullable=False)
    # Indicate the foreigner key
    user_id = Column(Integer, ForeignKey('users.id'))

    # TODO: Address表中的user是User表，back_populates是干啥的？
    user = relationship("User", back_populates="addresses")

# User表中的address是Address表
User.addresses = relationship(
    "Address", order_by=Address.id, back_populates="user")

# TODO: 这句可能是create table的
Base.metadata.create_all(engine)

# Add one objects
ed_user = User(name='ed', fullname='Ed Jones', nickname='edsnickname')
session.add(ed_user)
session.commit()

# Add multi objects
session.add_all([
    User(name='wendy', fullname='Wendy Williams', nickname='windy'),
    User(name='mary', fullname='Mary Contrary', nickname='mary'),
    User(name='fred', fullname='Fred Flintstone', nickname='freddy')])
session.commit()

# Query
our_user = session.query(User).\
    filter_by(name='ed').first()
print(our_user)

# Query, order_by
for instance in session.query(User).order_by(User.id):
    print(instance.name, instance.fullname)

# Query, indicate column
for name, fullname in session.query(User.name, User.fullname):
    print(name, fullname)

# Query, filter
for user in session.query(User).\
        filter(User.name=='ed').\
        filter(User.fullname=='Ed Jones'):
    print(user)

# Query, count
users_count = session.query(User).count()

# 单纯的query并不会出发sql查询，until the count() is called
# 所以query是some type，count是some type，可能是类似返回result的函数
q = session.query(User)
print(q.count())

# Efficient count
print(session.query(func.count(User.id)).scalar())

# Query, origin SQL
session.query(User).from_statement(
    text("SELECT * FROM users where name=:name")).params(name='ed').all()

# Add related objects
jack = User(name='jack', fullname='Jack Bean', nickname='gjffdd')
jack.addresses = [
    Address(email_address='jack@google.com'),
    Address(email_address='j25@yahoo.com')]
session.add(jack)
session.commit()

# Query related objects
jack = session.query(User).filter_by(name='jack').one()
print(jack)
for address in jack.addresses:
    print(address.email_address)

# Delete object, jack is querried up there
session.delete(jack)
session.query(User).filter_by(name='jack').count()

# is active
session.is_active
#+end_src
*** transaction
with session.begin(subtransactions=True):

*** Configuring Logging
**** logging to sys.stdout when create_engine()
create_engine.echo

create_engine.echo_pool

**** python logging
#+begin_src python :results output
logging.basicConfig()
logging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)
#+end_src

** setuptools
python3 setup.py bdist_rpm
*** pbr

*** files
**** packages
指定需要包含的包，行为类似于setuptools.find_packages

**** data_files
指定目的目录和源文件路径

* Openstack
** call back
#+begin_src python :results output
from neutron_lib.callbacks import events
from neutron_lib.callbacks import resources
from neutron_lib.callbacks import registry

"""
This method(notify) is deprecated in favor of publish() and will be removed in Queens.
"""

class PublishEventPayload(events.EventPayload):
    def __init__(self, context, metadata=None, request_body=None,
                 states=None, resource_id=None, name=None):

        super(PublishEventPayload, self).__init__(
            context, metadata=metadata, request_body=request_body,
            states=states, resource_id=resource_id)

        self.name = name


def module_callback(resource, event, trigger, payload):
    print('module callback got a payload of metadata = %s, name = %s' % (payload.metadata, payload.name))


class MyCallback(object):
    @staticmethod
    def object_callback(resource, event, trigger, payload):
        print('object callback')

    @classmethod
    def class_callback(cls, resource, event, trigger, payload):
        print('class callback')


c = MyCallback()
registry.subscribe(module_callback, resources.ROUTER, events.BEFORE_CREATE)
registry.subscribe(c.object_callback, resources.ROUTER, events.BEFORE_CREATE)
registry.subscribe(MyCallback.class_callback, resources.ROUTER, events.BEFORE_CREATE)


def notify_callback(resource, event, trigger, **kwargs):
    print('notify by %s, id is %s, name is %s' % (trigger.__name__, kwargs['id'], kwargs['name']))

registry.subscribe(notify_callback, resources.ROUTER, events.AFTER_CREATE)


def do_notify():
    def nested_subscribe(resource, event, trigger, payload):
        print('nested callback')

    registry.subscribe(nested_subscribe, resources.ROUTER, events.BEFORE_CREATE)

    # publish, why the order is indeterminate?
    registry.publish(resources.ROUTER, events.BEFORE_CREATE, do_notify, PublishEventPayload(None, metadata='btw', name='moka'))

    # notify
    registry.notify(resources.ROUTER, events.AFTER_CREATE, do_notify, id='10', name='your_name')


print('Notifying...')
do_notify()

#+end_src

* Todo
** click

** lambda

** @abc.abstractmethod
修饰的抽象类的函数入参怎么写

子类入参要完全一致吗

可以控制子类必须包含哪些入参吗
